var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"yGuard","text":"<p><code>yGuard</code> is an open-source Java obfuscation tool. With <code>yGuard</code>, it is easy as pie (\ud83c\udf70) to configure obfuscation through an extensive ant task. This documentation explains how to use the <code>yGuard</code> Java obfuscation and shrinking software.</p> <p>yGuard is brought to you by yWorks GmbH, creator of the family of graph and diagram visualization frameworks yFiles and other excellent products.</p> <p><code>yGuard</code> comes with a exhaustive set of examples to cover a broad range of use cases. When in doubt, look up the examples for solutions.</p>"},{"location":"index.html#table-of-contents","title":"Table of contents","text":"<ul> <li>Setup<ul> <li>Using <code>Ant</code></li> <li>Using <code>Maven</code></li> <li>Using <code>Gradle</code></li> </ul> </li> <li>Task documentation</li> <li>Examples</li> <li>Troubleshooting</li> <li>Compatibility</li> <li>License</li> </ul>"},{"location":"index.html#problems-and-bug-reports","title":"Problems and Bug Reports","text":"<p>If you experience any problems or think you have found a bug feel free to open an issue on our public issue tracker. Please make sure you have read the documentation thoroughly before. We will do our best and try to answer your questions.</p>"},{"location":"compatibility.html","title":"Compatibility","text":""},{"location":"compatibility.html#technical-requirements","title":"Technical requirements","text":"<p>yGuard requires JDK 1.7.x or greater and Ant 1.5 or greater installed on your system. It may work with earlier versions of these pieces of software as well, however this has not been tested thoroughly. yGuard 1.3.x and upwards works together with Ant 1.6.</p>"},{"location":"compatibility.html#java-14-java-17-compatibility","title":"Java 14 - Java 17 Compatibility","text":"<p>Beginning with version 3.1.0, yGuard supports obfuscation of Java class files that contain <code>record</code> or <code>permittedsubclasses</code> attributes which were introduced with the Java 16 and Java 17 <code>.class</code> file formats.</p>"},{"location":"compatibility.html#java-11-java-13-compatibility","title":"Java 11 - Java 13 Compatibility","text":"<p>Beginning with version 2.10, yGuard supports obfuscation of Java class files that contain <code>nesthost</code> or <code>hestmembers</code> attributes which were introduced with the Java 11 <code>.class</code> file format.</p> <p>yGuard does not support obfuscating <code>dynamic</code> instructions which were introduced with the Java 11 <code>.class</code> file format.</p> <p>Please read the notes regarding 3rd party JVM support if you intend to use yGuard with something other than Java.</p>"},{"location":"compatibility.html#java-9-java-10-compatibility","title":"Java 9 / Java 10 Compatibility","text":"<p>Beginning with version 2.7, yGuard supports obfuscation of Java class files that contain module information which was introduced with the Java 9 <code>.class</code> file format. yGuard does not change module names, though.</p> <p>yGuard does not support obfuscating multi-release Java archives which were introduced with Java 9.</p>"},{"location":"compatibility.html#java-7-java-8-compatibility","title":"Java 7 / Java 8 Compatibility","text":"<p>Beginning with version 2.5, yGuard supports obfuscation of Java class files that contain the <code>invokedynamic</code> instruction, which was introduced with the Java 7 <code>.class</code> file format. JDK 7 does not contain any means of issuing this instruction, with JDK 8 it is being issued when using lambda expressions or default methods.</p> <p>While yGuard does fully support obfuscating <code>invokedynamic</code> instructions and therefore default methods and lambda expressions, shrinking of Java class files that contain this instruction is not supported yet.</p>"},{"location":"compatibility.html#compatibility-to-3rd-party-jvm","title":"Compatibility to 3rd party JVM","text":"<p>Obfuscating <code>dynamic</code> and <code>invokedynamic</code> instructions is a task that is theoretically infeasible. An obfuscation program cannot determine the type and parameters of such instructions in a generic way. A trade-off solution for this is supporting known <code>MetaFactory</code> objects by their signature. The <code>JRE</code> makes this task quite trivial.  <code>yGuard</code> supports the built-in <code>LambdaMetafactory</code> and <code>StringConcatFactory</code>.</p> <p>This trade-off however means <code>yGuard</code> offers only limited support for instruction sets based on <code>invokedynamic</code> or <code>dynamic</code>. In particular, supporting new <code>JVM</code> targets, such as Scala, might require manual work. As we currently do not have the expertise, nor do we have the resources for this project, this is a chore left for the community.</p> <p>Below is a documentation on the design process involved in supporting the <code>LambdaMetafactory</code>. It should serve as a base for anyone deciding to add more support for e.g Scala or Groovy.</p>"},{"location":"compatibility.html#how-lambdametafactory-is-covered","title":"How <code>LambdaMetafactory</code> is covered","text":"<p>To check that JVM compatibility is ensured in new releases, we verified that there are no differences in the class file format in JVM &gt;= 11. This can be checked in the documentation of the class file format. The JRE ships two targets for the <code>invokedynamic</code> and <code>dynamic</code> instruction sets. These are:</p> <ul> <li><code>LambdaMetafactory</code></li> <li><code>StringConcatFactory</code></li> </ul> <p>We can recognise these factories in the obfuscation and shrinking steps using their signature.  Looking at the documentation tells us that we should cover two signatures for <code>LambdaMetaFactory</code>:</p> <ul> <li><code>java/lang/invoke/LambdaMetafactory#metafactory</code></li> <li><code>java/lang/invoke/LambdaMetafactory#altMetafactory</code></li> </ul> <p><code>yFiles</code> recognises these methods during renaming. In order to obfuscate lambdas, these steps are performed:</p> <ul> <li>if an instance of <code>InvokeDynamicCpInfo</code> is found while parsing the constant pool, check its signature</li> <li>if it has a <code>LambdaMetafactory</code> signature handle the special case</li> </ul> <p>In the <code>LambdaMetafactoryTest</code> example, this will remap <code>com/yworks/yguard/obf/LambdaMetaFactoryTest$MyInterface;</code> to <code>La/a/a/a/a$_a;</code>. Most instances of lambda invocations will do a remapping on the JRE functional interface.</p> <p>However, this process must be carefully tested with actual Java byte code. Even though <code>StringConcatFactory</code> uses similar code, its semantics is completely different. Implementing such a factory requires in-depth knowledge of the underlying mechanism. Even in the case of the <code>JDK</code> it is not always perfectly clear which case will be mapped by the compiler to which construct.</p>"},{"location":"license.html","title":"License","text":"<p><code>yGuard</code> is licensed under the <code>MIT</code> license.</p> <p>All 3rd party licenses can be found in the <code>3rdPartyLicenses</code> folder.</p>"},{"location":"setup.html","title":"Setup","text":""},{"location":"setup.html#setup","title":"Setup","text":"<p>Depending on your build system, you will use <code>AntRun</code> or <code>Ant</code> directly to run <code>yGuard</code>.</p>"},{"location":"setup.html#setup-using-ant","title":"Setup using <code>Ant</code>","text":"<p>Download the bundle from the Github release page. After downloading and extracting the <code>jar</code> files, place them in a path near to your build script. You may use absolute paths, but our examples expect the jar file to lie in the same directory as your build file. Once extracted, you can use the <code>yguard</code> element like so:</p> <pre><code>&lt;property name=\"version\" value=\"4.0.0\"/&gt;\n\n&lt;target name=\"yguard\"&gt;\n    &lt;taskdef name=\"yguard\" classname=\"com.yworks.yguard.YGuardTask\" classpath=\"${projectDir}/yguard-${version}.jar\"/&gt;\n    &lt;yguard&gt;\n        &lt;!-- see the yGuard task documentation for information about the &lt;yguard&gt; element--&gt;\n    &lt;/yguard&gt;\n&lt;/target&gt;\n</code></pre>"},{"location":"setup.html#setup-using-maven","title":"Setup using <code>Maven</code>","text":"<p>You can use <code>yGuard</code> directly from <code>Maven</code> central. Add the <code>yGuard</code> dependency to your <code>POM</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.yworks&lt;/groupId&gt;\n    &lt;artifactId&gt;yguard&lt;/artifactId&gt;\n    &lt;version&gt;4.0.0&lt;/version&gt;\n    &lt;scope&gt;compile&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Once declared, you can use the <code>antrun</code> plugin to define the <code>yGuard</code> task like so:</p> <pre><code>&lt;plugin&gt;\n    &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.8&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;phase&gt;package&lt;/phase&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;run&lt;/goal&gt;\n            &lt;/goals&gt;\n            &lt;id&gt;obfuscate&lt;/id&gt;\n            &lt;configuration&gt;\n                &lt;tasks&gt;\n                    &lt;property name=\"runtime_classpath\" refid=\"maven.runtime.classpath\"/&gt;\n                    &lt;taskdef name=\"yguard\" classname=\"com.yworks.yguard.YGuardTask\" classpath=\"${runtime_classpath}\"/&gt;\n                    &lt;yguard&gt;\n                       &lt;!-- see the yGuard task documentation for information about the &lt;yguard&gt; element--&gt;\n                    &lt;/yguard&gt;\n                &lt;/tasks&gt;\n            &lt;/configuration&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre>"},{"location":"setup.html#setup-using-gradle","title":"Setup using <code>Gradle</code>","text":"<p>You can use <code>yGuard</code> directly from <code>Maven</code> central. You can define and use <code>yGuard</code> in your <code>build.gradle</code>:</p> <pre><code>repositories {\n  mavenCentral()\n}\n\ndependencies {\n  compileOnly 'com.yworks:yguard:4.0.0'\n}\n\ntask yguard {\n  group 'yGuard'\n  description 'Obfuscates and shrinks the java archive.'\n\n  doLast {\n    ant.taskdef(\n        name: 'yguard',\n        classname: 'com.yworks.yguard.YGuardTask',\n        classpath: sourceSets.main.compileClasspath.asPath\n    )\n\n    ant.yguard {\n        // see the yGuard task documentation for information about the yGuard element\n    }\n  }\n}\n</code></pre>"},{"location":"task_documentation.html","title":"Task documentation","text":""},{"location":"task_documentation.html#preamble","title":"Preamble","text":"<p>Using the <code>yGuard</code> Ant task, name obfuscation and code shrinking can be seamlessly integrated into your deployment process.</p> <p>The <code>yguard</code> task contains two nested elements that perform the name obfuscation and code shrinking separately:</p> <ul> <li>The rename element performs name-obfuscation, renaming all packages, classes, methods and fields according to a selectable name-mapping scheme. Elements can be excluded from the renaming process by annotating them with a certain annotation class in the source code or using a nested keep element.</li> <li>The shrink element removes all code elements that are not reachable from the entrypoints given in the nested keep element.</li> </ul>"},{"location":"task_documentation.html#table-of-contents","title":"Table of contents","text":"<ul> <li><code>yguard</code> element<ul> <li><code>inoutpair</code> element</li> <li><code>externalclasses</code> element</li> <li><code>attribute</code> element</li> <li><code>rename</code> element<ul> <li><code>property</code> element</li> <li><code>patch</code> element</li> <li><code>adjust</code> element</li> <li><code>map</code> element<ul> <li><code>package</code> element</li> <li><code>class</code> element</li> <li><code>method</code> element</li> <li><code>field</code> element</li> </ul> </li> </ul> </li> <li><code>shrink</code> element<ul> <li><code>entrypointjar</code> element</li> </ul> </li> <li><code>keep</code> element</li> </ul> </li> <li>Controlling obfuscation exclusion with annotations</li> <li>Generating patch JARs</li> <li>Deobfuscating stacktraces</li> <li>DTD used for Ant <code>&lt;yguard&gt;</code></li> </ul>"},{"location":"task_documentation.html#the-yguard-element","title":"The yguard Element","text":"<p>The <code>yguard</code> task is a container element for the <code>rename</code> and <code>shrink</code> task elements as well as configuration elements that are common to <code>rename</code> and <code>shrink</code>. Being a container element only, the <code>yguard</code> task does not perform any actions on its own, but needs a <code>rename</code> and/or <code>shrink</code> child element for name obfuscating and/or code shrinking.</p> <p>Please see the troubleshooting section to learn about common pitfalls when using name obfuscation and shrinking software.</p>"},{"location":"task_documentation.html#attributes","title":"Attributes","text":"<p>The <code>yguard</code> element has no attributes.</p>"},{"location":"task_documentation.html#child-elements","title":"Child Elements","text":"<ul> <li>inoutpair</li> <li>externalclasses</li> <li>attribute</li> <li>rename</li> <li>shrink</li> </ul>"},{"location":"task_documentation.html#the-inoutpair-element","title":"The <code>inoutpair</code> Element","text":"<p>At least one <code>inoutpair</code> element or one non-empty <code>inoutpairs</code> element has to be specified in order to run the <code>yguard</code> tasks. This element specifies the paths to the input and output jar files.</p> <p><code>inoutpair</code> also supports the usage of directories. This is detected by File.isDirectory. However, in general you do not want to use directories for <code>inoutpairs</code> (advanced use cases).</p>"},{"location":"task_documentation.html#attributes_1","title":"Attributes","text":"Attribute Description Required <code>in</code>      Specifies an exisiting jar file, which contains the unshrinked and     unobfuscated .class files.      Yes <code>out</code>      Specifies a path to a jar file which will be created and used to     put the results of the shrinking and obfuscation process.      Yes <code>resources</code>      Will only be considered if the     <code>yguard</code> element     contains a nested     <code>shrink</code> element.          Determines how the shrinking engine handles all non-.class files.          Currently the following three resource policies are supported:     <ul> <li><code>copy</code>         the default, simply copies all resource files to the output jar.         </li> <li><code>auto</code>         copies only those resource files that reside in a directory that         still contains one or more .class files after shrinking.         </li> <li><code>none</code>         discards all resource files.         </li> </ul>      No, defaults to <code>copy</code>."},{"location":"task_documentation.html#child-elements_1","title":"Child Elements","text":"<p>The <code>inoutpair</code> element has no child elements.</p> <p>If multiple jar files need to be obfuscated at once the <code>inoutpairs</code> element can be used alternatively.</p>"},{"location":"task_documentation.html#the-inoutpairs-elements","title":"The <code>inoutpairs</code> Elements","text":"<p>Additionally or alternatively to <code>inoutpair</code> elements this element can be specified in order to specify the paths to the input and output jar files.</p>"},{"location":"task_documentation.html#attributes_2","title":"Attributes","text":"Attribute Description Required <code>resources</code>      Will only be considered if the     <code>yguard</code> element     contains a nested     <code>shrink</code> element.          Determines how the shrinking engine handles all non-.class files.          Currently the following three resource policies are supported:     <ul> <li><code>copy</code>         the default, simply copies all resource files to the output jar.         </li> <li><code>auto</code>         copies only those resource files that reside in a directory that         still contains one or more .class files after shrinking.         </li> <li><code>none</code>         discards all resource files.         </li> </ul>      No, defaults to <code>copy</code>."},{"location":"task_documentation.html#child-elements_2","title":"Child Elements","text":"<ul> <li>patternset</li> <li>optionally a mapper that determines the name mapping between the unobfuscated and obfuscated versions of the jar files. Note that <code>identitymapper</code> and <code>mergemapper</code> are not supported. All matched jar file names need to be mapped to exactly one jar file name that differs from the original jar file.</li> </ul>"},{"location":"task_documentation.html#examples","title":"Examples","text":"<pre><code>&lt;!-- use all jars in the input-lib-dir directory and obfuscate them to *_obf.jar --&gt;\n&lt;inoutpairs resources=\"auto\"&gt;\n  &lt;fileset dir=\"${input-lib-dir}\"&gt;\n    &lt;include name=\"myapp*.jar\"/&gt;\n    &lt;exclude name=\"*_obf.jar\"/&gt;\n  &lt;/fileset&gt;\n  &lt;mapper type=\"glob\" from=\"*.jar\" to=\"*_obf.jar\"/&gt;\n&lt;/inoutpairs&gt;\n\n&lt;!-- the above mapper is the default one so the following snippet does the same --&gt;\n&lt;inoutpairs resources=\"auto\"&gt;\n  &lt;fileset dir=\"${input-lib-dir}\"&gt;\n    &lt;include name=\"myapp*.jar\"/&gt;\n    &lt;exclude name=\"*_obf.jar\"/&gt;\n  &lt;/fileset&gt;\n&lt;/inoutpairs&gt;\n</code></pre>"},{"location":"task_documentation.html#the-externalclasses-element","title":"The <code>externalclasses</code> Element","text":"<p>If the jar to be processed by <code>yGuard</code> depends on external classes or libraries, this element can be used to specify classpaths to these entities. These libraries will neither be shrinked nor obfuscated. Use the <code>inoutpair</code> element for this purpose! See the <code>external_library</code> example for an example of when to use this element. In order to achieve a maximum shrinking effect by the <code>shrink</code> task, all external dependencies should be declared in the <code>externalclasses</code> element. Otherwise, all non-private methods of classes that inherit from unresolvable classes will not be shrinked.</p> <p>The elements attributes and child elements can be seen on the Ant documentation page about using path elements.</p>"},{"location":"task_documentation.html#the-attribute-element","title":"The attribute Element","text":"<p>Using the <code>attribute</code> element, you can specify which attributes present in the input classes should be kept in the obfuscated output classes.</p> <p>See the <code>linked_example</code> for an example of when to use this element.</p>"},{"location":"task_documentation.html#attributes_3","title":"Attributes","text":"Attribute Description Required <code>name</code> A comma-separated list of attribute names that are to     be retained in the shrinked and/or     obfuscated class     files.      Yes"},{"location":"task_documentation.html#child-elements_3","title":"Child Elements","text":"<ul> <li>patternset</li> </ul>"},{"location":"task_documentation.html#example","title":"Example","text":"<pre><code>&lt;attribute name=\"SourceFile, LineNumberTable, LocalVariableTable\"&gt;\n  &lt;patternset&gt;\n    &lt;include name=\"com.mycompany.mylibrary.**\"/&gt;\n  &lt;/patternset&gt;\n&lt;/attribute&gt;\n</code></pre> <p>This will retain the attributes named \"SourceFile\", \"LineNumberTable\", and \"LocalVariableTable\" effectively enabling debugging information for all classes in the <code>com.mycompany.mylibrary</code> package and subpackages.</p>"},{"location":"task_documentation.html#the-shrink-element","title":"The <code>shrink</code> Element","text":"<p>The <code>shrink</code> task removes all classes, fields and methods that are not reachable from a number of entrypoints given by a nested keep element. See the examples explanation of some common use cases. If your code uses reflection, please read the troubleshooting section for information on this topic.</p>"},{"location":"task_documentation.html#attributes_4","title":"Attributes","text":"Attribute Description Required <code>logfile</code> Determines the name of the logfile that is generated     during the shrinking process. The logfile contains information about     the entrypoints the shrinking engine uses, the removed classes,     methods and fields as well as any warnings.          If the name ends with a \".gz\", yGuard will automatically create a     gzipped version of the file which potentially saves a lot of disc     space.           No, defaults to<code>yshrinklog.xml</code> <code>createStubs</code>      Instead of removing methods completely, this attribute causes the     <code>shrink</code> task to insert a method     stub that throws a <code>java.lang.InternalError</code> if it is     called. This attribute is very useful if the shrinking process     causes your application to break and you are uncertain about which     additional code entities you have to include in the     <code>keep</code>element.      Note that classes considered as completely obsolete by the shrinking     engine are still removed completely - this attribute only     affects obsolete methods of non-obsolete classes.           No, defaults to <code>false</code>"},{"location":"task_documentation.html#child-elements_4","title":"Child Elements","text":"<ul> <li>keep</li> <li>entrypointjar</li> </ul>"},{"location":"task_documentation.html#the-entrypointjar-element","title":"The <code>entrypointjar</code> Element","text":"<p>The <code>entrypointjar</code> element can be used for convenience if your application uses libraries that are to be shrinked, but the jarfile using these libraries should be left untouched by the shrinking engine. Such a jarfile could be specified as an <code>entrypointjar</code>.</p>"},{"location":"task_documentation.html#attributes_5","title":"Attributes","text":"Attribute Description Required <code>name</code> Path to to the jar file to use as entrypointjar. Yes"},{"location":"task_documentation.html#child-elements_5","title":"Child Elements","text":"<p>The <code>entrypointjar</code> element has no child elements.</p>"},{"location":"task_documentation.html#example_1","title":"Example","text":"<pre><code>&lt;yguard&gt;\n  &lt;inoutpair in=\"lib-in.jar\" out=\"lib-out.jar\" /&gt;\n  &lt;shrink&gt;\n    &lt;entrypointjar name=\"myApp.jar\"/&gt;\n  &lt;/shrink&gt;\n&lt;/yguard&gt;\n</code></pre>"},{"location":"task_documentation.html#the-rename-element","title":"The <code>rename</code> Element","text":"<p>The basic idea is, that all elements will be renamed by this task. There are different use cases, where you sometimes want to exclude or simply just have to exclude some elements from name obfuscation, i.e. not rename them but keep in the API as is. See the examples for explanation of some common use cases. If your code uses reflection, please read the troubleshooting section for information on this topic. Excluding elements can be achieved by using the keep element, the <code>mainclass</code> attribute of the <code>rename</code> element and by annotating elements in the source code with the annotation that is specified in the <code>annotationClass</code> attribute of the <code>rename</code> element. Using the nested <code>keep</code> element, you have to specify all classes, methods, fields, and attributes that should be excluded from name obfuscation. Another way is to annotate the elements directly in the source code that should be obfuscated or excluded. You can use the yFiles obfuscation annotation <code>com.yworks.util.annotation.Obfuscation</code> for that or specify your own annotation in the <code>annotationClass</code> attribute of this element.</p> Attribute Description Required <code>mainclass</code> Can be used as a shortcut to specify the mainclass     of your application. Both the class name and the main method will be     excluded from name obfuscation.     Alternatively you may want to consider to exclude the main method     only. If your jar contains a <code>Main-Class</code> attribute, the     <code>rename</code> task will automatically adjust     the value to the obfuscated     name.      No <code>logfile</code> Determines the name of the logfile that is generated     during the renaming process. The logfile contains information about     the mappings the name obfuscator generates as well as any warnings.          If the name ends with a \".gz\", yGuard will automatically create a     gzipped version of the file which potentially saves a lot of disc     space.           No, defaults to<code>yguardlog.xml</code> <code>conservemanifest</code>      A boolean attribute (valid values:     <code>true</code>/<code>false</code>) that determines whether the     manifest file of the jars should be left untouched by the renaming     engine. If set to <code>false</code>, the manifest will be modified     to reflect the new message digests.           No, defaults to <code>false</code>.      <code>replaceClassNameStrings</code>      A boolean attribute (valid values:     <code>true</code>/<code>false</code>) that determines whether the     renaming engine should try to replace hardcoded Strings, which     are used in conjunction with the <code>MyClass.class</code>     construct.     If set to <code>false</code>, those Strings will be left untouched     and code of the form <code>MyClass.class</code> will break if     MyClass gets obfuscated by name. If set to <code>true</code> (the     default), yGuard will try to workaround this problem by replacing     the hardcoded String with the appropriate obfuscated name. However     this will only work if the unobfuscated class file has been     generated with the usual compilers ('javac', 'jikes' and 'bjc') or     compilers, that produce similar bytecode. This can also have the     side-effect of modifying too many Strings, e.g if you have code that     looks like<code>System.out.println(\"com.mycompany.MyClass\");</code>,     it might get replaced, if <code>MyClass.class</code> resides in the     very same class with something like     <code>System.out.println(\"com.A.OoO\");</code>. It will most likely     fail if the class has been previously obfuscated by another     obfuscation tool or a different compiler has been used for     compilation. Anyway it is always worth it to give it a try, if you     want to have 'full obfuscation'.           No, defaults to <code>true</code> <code>scramble</code>              A boolean attribute (valid values: <code>true</code>/<code>false</code>)             that determines whether the renaming engine should generate pseudorandom             name mappings for each invocation. If set to <code>false</code> (the             default, for backward compatibility), each obfuscation will used a             fixed map that generates names based on the order of the obfuscated             elements. If nothing is changed, each obfuscation will generate the             same obfuscated names for all elements. If set to <code>true</code>,             yGuard generates pseudorandom mappings (using <code>java.util.Random</code>)             that produce different obfuscated names in each build even if the             unobfuscated source is unchanged.                         No, defaults to <code>false</code> <code>annotationClass</code>      Specifies the name of the annotation class that can be used to     exclude elements by annotating them in the source code. The     specified annotation can be any annotation that fits the convention.           No, defaults to <code>com.yworks.util.annotation.Obfuscation</code>"},{"location":"task_documentation.html#child-elements_6","title":"Child Elements","text":"<ul> <li>keep</li> <li>property</li> <li>patch</li> <li>adjust</li> <li>map</li> </ul>"},{"location":"task_documentation.html#the-property-element","title":"The property Element","text":"<p><code>property</code> elements can be used to give hints to the name obfuscation engine. Depending on the exact version of yGuard, the task may use these hints to control the process of obfuscation.</p>"},{"location":"task_documentation.html#attributes_6","title":"Attributes","text":"Attribute Description Required <code>name</code>      Specifies a key which may be interpreted by the obfuscation task.      Yes <code>value</code>      Specifies the corresponding value of the property.      Yes"},{"location":"task_documentation.html#supported-properties","title":"Supported properties","text":"Name Description Default <code>error-checking</code>      Can be used to tell yGuard to bail out if it detects any problems.     Currently this property can be set to the following value:     <ul> <li> <code>pedantic</code>         Will make the obfuscation run fail, i.e. the target which uses         the <code>rename</code>element will fail, if         yGuard detects any problems.         </li> </ul> <code>false</code> <code>naming-scheme</code>      Can be used to tell the renaming engine to use a different naming     scheme during the obfuscation.     Currently this property can be set to one of the following values:     <ul> <li> <code>small</code>         Will produce very short names, i.e. the resulting jar         file will be as small as possible.         </li> <li> <code>best</code>         Will produce names, that are very likely to be misunderstood by         decompilers and disassemblers. Using this naming-scheme it is         even impossible on most filesystems to successfully unjar or         unzip the resulting jar file (Windows, Standard Unix, Standard         Linux, MacOS).         However this scheme takes up a lot of space and the resulting         jar is likely to become large (typically roughly double the         size).         </li> <li> <code>mix</code>         Is a mixture of both the other two values, which leads to         reasonable small but still hard to decompile jar files.         </li> </ul> <code>small</code> <code>language-conformity</code>      Can be used to advise the renaming engine to produce names, that     should be decompilable by most decompilers. On the other hand,     yGuard can produce class files that should be executable and     verifiable by all of todays virtual machines, but produces     absolutely nonsense names when decompiled (Ever tried to compile     '<code>int class = false.this super(String$super.init if);</code>'     ?!)     Currently this property can be set to one of the following values:     <ul> <li> <code>compatible</code>         Will produce names, that are ok for (most) decompilers, java,         jar and manifest files and can be unzipped to most filesystems.         </li> <li> <code>legal</code>         Will produce names, that are ok for (some) decompilers, java,         jar and manifest files.         </li> <li> <code>illegal</code>         Will produce names, that will crash some tools but usually         not the jvm, but JBuilder7 in many occasions for example.         </li> </ul> <code>legal</code> <code>overload-enabled</code>      Determines whether the renaming engine tries to use the same names     for methods with different signatures or whether it always generates     unique method names.     Setting this property to <code>false</code> eases the analysis of     stacktraces but reduces the obfuscation effect.      <code>true</code> <code>obfuscation-prefix</code>      Can be used to instruct the renaming engine to prefix packages, that     are fully obfuscated with a given package prefix, e.g.     <code>com.mycompany.obf</code>.      - <code>digests</code>      Can be used to tell yGuard which digest algorithms should be used     for the digest generation in the manifest file. Valid values are     either <code>none</code>, or a comma-separated     list of digest-algorithm identifiers, e.g.     <code>SHA-1, MD5</code> (which is the default).      <code>SHA-1, MD5</code> <code>expose-attributes</code>      Can be used to give yGuard a list of attributes yGuard should expose     in addition to the standard attributes.     By default yGuard removes unneeded attributes like \"Deprecated\" from     methods. The value can be a comma separated list of attributes as     defined in     Section 4.7 of the VM Specification of the .class File Format.     E.g. in order to keep the \"Deprecated\" attribute one can add the     following property:      <code>&lt;property name=\"expose-attributes\" value=\"Deprecated\"/&gt;</code>      Note that this affects all classes which will be obfuscated. For a     better control of which attributes should be exposed in what classes     use the Attribute Element.      -"},{"location":"task_documentation.html#child-elements_7","title":"Child Elements","text":"<p>The <code>property</code> element has no child elements.</p>"},{"location":"task_documentation.html#the-keep-element","title":"The <code>keep</code> Element","text":"<p>This element is a child of the rename or shrink element. It can be used to specify elements that are excluded from the parent <code>rename</code> or <code>shrink</code> task. The excluded classes, methods and fields are defined using nested package, class, method and field elements.</p>"},{"location":"task_documentation.html#attributes_7","title":"Attributes","text":"<p>The <code>keep</code> element provides a number of boolean attributes that determine whether debug information and annotations present in the input class files are to be retained in the output files. The default behavior of the <code>rename</code> and <code>shrink</code> elements for the respective attributes is explained in the table below. Note that a more fine-grained control over which attributes to keep for which class files is possible using the attribute element. Also, the <code>attribute</code> element allows to define attributes to keep for both the rename and the shrink element in a common place.</p> Attribute Description Default (<code>rename</code>) Default (<code>shrink</code>) <code>sourcefile</code>      Determines whether the name of the original source code file should     be included in the output class files.      <code>remove</code> <code>remove</code> <code>linenumbertable</code>      Determines whether the line number table, that contains a mapping     from each opcode in the class file to the line number in the     original source code file should be included in the output class     files.      <code>remove</code> <code>remove</code> <code>localvariabletable</code>      Determines whether the local variable table, that contains a mapping     from each local variable in the class file to the name that has been     used in the original source code file should be included in the     output class files.      <code>remove</code> <code>remove</code> <code>localvariabletypetable</code>      Determines whether the local variable type table, that contains a     mapping from each local variable in the class file to the name and     its generic type signature that has been used in the original source     code file should be included in the output class files.      <code>remove</code> <code>remove</code> <code>runtimevisibleannotations</code>      Determines whether annotations with the retention policy     <code>RetentionPolicy.RUNTIME</code>should be included in the output     class files.      <code>keep<sup>1</sup></code> <code>keep</code> <code>runtimevisibleparameterannotations</code>      Determines whether method paramater annotations with the retention     policy <code>RetentionPolicy.RUNTIME</code> should be included in     the output class files.      <code>keep<sup>1</sup></code> <code>keep</code> <code>runtimevisibletypeannotations</code>      Determines whether type annotations with the retention     policy <code>RetentionPolicy.RUNTIME</code> should be included in     the output class files.      <code>keep<sup>1</sup></code> <code>keep</code> <code>runtimeinvisibleannotations</code>      Determines whether annotations with the retention policy     <code>RetentionPolicy.CLASS</code>should be included in the output     class files.      <code>keep<sup>1</sup></code> <code>remove</code> <code>runtimeinvisibleparameterannotations</code>      Determines whether method paramater annotations with the retention     policy <code>RetentionPolicy.CLASS</code> should be included in the     output class files.      <code>keep<sup>1</sup></code> <code>remove</code> <code>runtimeinvisibletypeannotations</code>      Determines whether type annotations with the retention     policy <code>RetentionPolicy.CLASS</code> should be included in the     output class files.      <code>keep<sup>1</sup></code> <code>remove</code> <p><sup>1</sup> <code>rename</code> always keeps annotations irrespective of its <code>runtime*annotations</code> attribute values.</p>"},{"location":"task_documentation.html#the-class-element","title":"The <code>class</code> Element","text":"<p>The <code>class</code> element can be used for excluding certain classes and/or their fields and methods from the renaming or shrinking process. If no <code>name</code>, <code>extends</code> or <code>implements</code> attribute is given and the <code>class</code> element contains no nested <code>patternset</code>, a <code>class</code> element matches all class names.</p> <p>The <code>classes</code>, <code>methods</code> and <code>fields</code> attributes tell the shrinking and renaming engines which classes, methods and fields to keep based on their visibility. The following table lists the possible values for all of these attributes and shows which elements will be excluded. A '*' denotes, that elements that have the given visibility will be excluded for the specified attribute value. A '-' denotes that the these elements will not be excluded from the process.</p> Value/Visibility <code>public</code> <code>protected</code> <code>friendly</code> <code>private</code> <code>none</code> - - - - <code>public</code> * - - - <code>protected</code> * * - - <code>friendly</code> * * * - <code>private</code> * * * *"},{"location":"task_documentation.html#attributes_8","title":"Attributes","text":"Attribute Description Required <code>name</code> The name of the class to be kept. No <code>classes</code> The visibility of the classes to be kept.      No, defaults to <code>none</code> <code>methods</code> The visibility of the methods to be kept.      No, defaults to <code>none</code> <code>fields</code> The visibility of the fields to be kept.      No, defaults to <code>none</code> <code>extends</code>      If no <code>name</code> attribute is given, keeps     all classes that equal or extend the class defined by the given     fully qualified classname.          See serializable_example for an example usage of this     attribute.      No <code>implements</code>      If no <code>name</code> attribute is given, keeps     all classes that equal or implement the class defined by the given     fully qualified classname.          See serializable_example for an example usage of this     attribute.      No"},{"location":"task_documentation.html#child-elements_8","title":"Child elements","text":"<ul> <li>patternset</li> </ul>"},{"location":"task_documentation.html#explanation","title":"Explanation","text":"<p>There are three possible ways of specifying which classes will be excluded from the shrinking and obfuscation process:</p> <p>1) One can specify a single java class using the fully qualified name in java syntax with the name attribute. For example:</p> <pre><code>&lt;class name=\"mypackage.MyClass\"/&gt;\n</code></pre> <p>2) One can specify multiple java classes using a modified version of a patternset. The patternset's includes and excludes element should use java syntax, but the usual wildcards are allowed. Some examples:</p> <pre><code>&lt;class&gt;\n  &lt;patternset&gt;\n    &lt;include name=\"com.mycompany.**.*Bean\"/&gt;\n    &lt;exclude name=\"com.mycompany.secretpackage.*\"/&gt;\n    &lt;exclude name=\"com.mycompany.myapp.SecretBean\"/&gt;\n  &lt;/patternset&gt;\n&lt;/class&gt;\n</code></pre> <p>3) This will expose all classes which reside in the package subtree of <code>com.mycompany</code> and whose name ends with <code>Bean</code> except for those, that reside in the <code>com.mycompany.secretpackage</code> package and the single <code>SecretBean</code> in <code>com.mycompany.myapp</code>.</p> <pre><code>&lt;class&gt;\n  &lt;patternset&gt;\n    &lt;include name=\"com.mycompany.myapp.MainClass\"/&gt;\n    &lt;include name=\"org.w3c.sax?.\"/&gt;\n    &lt;exclude name=\"org.w3c.sax?.**.*$$*\"/&gt;\n  &lt;/patternset&gt;\n&lt;/class&gt;\n</code></pre> <p>This will expose the <code>MainClass</code> class and all classes, which reside in packages like <code>org.w3c.sax1</code>, <code>org.w3c.sax2</code>, <code>org.w3c.saxb</code> except for inner classes. <code>'$'</code> is used as a separator between outer class names and inner class names. Since Ant uses <code>'$'</code> as an escape character, you have to use two consecutive <code>'$'s</code> (<code>'$$'</code>) if you want to pass one as an argument to the task.</p> <p>4) Finally one can specify classes depending on their visibility, i.e. depending whether they have been declared <code>public</code>, <code>protected</code>, <code>package-private</code> or <code>private</code> (inner classes). This can be achieved by additionally specifying the classes attribute in the class element.</p> <pre><code>&lt;class classes=\"protected\"&gt;\n  &lt;patternset&gt;\n    &lt;include name=\"com.mycompany.myapi.\"/&gt;\n  &lt;/patternset&gt;\n&lt;/class&gt;\n</code></pre> <p>This will keep all class names, that are either <code>public</code> or <code>protected</code> and which reside in one of the subpackages of <code>com.mycompany.myapi</code> (note the abbreviation: the trailing dot behaves like the trailing <code>'/'</code> in the usual patternset, i.e. it could be rewritten as <code>com.mycompany.myapi.**.*</code>)</p> <pre><code>&lt;class classes=\"protected\"\n  methods=\"protected\"\n  fields=\"protected\"&gt;\n  &lt;patternset&gt;\n    &lt;include name=\"**.*\"/&gt;\n  &lt;/patternset&gt;\n&lt;/class&gt;\n</code></pre> <p>This example shows the very common use case of excluding a complete public API from the shrinking and obfuscation process. There is an abbreviation for this use case: you can omit the <code>patternset</code> element, since in the case where the <code>classes</code> attribute is specified and there is no <code>patternset</code> child element used, the task will automatically apply this rule. In this example all classes will be exposed, that are either <code>public</code> or <code>protected</code>. Their methods and fields will be exposed as long as they are declared <code>public</code> or <code>protected</code>. If a class is <code>package-private</code> or <code>private</code> (inner classes), neither itself nor its methods or fields will be exposed.</p> <p>The last example shows how to keep the <code>public</code> methods of certain classes only, but neither field names nor the class names themselves.</p> <pre><code>&lt;class classes=\"none\" methods=\"public\" fields=\"none\"&gt;\n  &lt;patternset&gt;\n    &lt;include name=\"com.mycompany.myapi.\"/&gt;\n  &lt;/patternset&gt;\n&lt;/class&gt;\n</code></pre>"},{"location":"task_documentation.html#the-method-element","title":"The <code>method</code> Element","text":"<p>Using the <code>method</code> element you can specify methods by signature which should be excluded from shrinking or name obfuscation.</p>"},{"location":"task_documentation.html#attributes_9","title":"Attributes","text":"Attribute Description Required <code>name</code>      Specifies the method to keep. Use the complete signature using     fully qualified class names and the return type!      Yes <code>class</code>      Specifies the class which contains the method. Use the normal java     syntax, i.e. the fully qualified name.     This attribute can be omitted, if the patternset element is used as     a child element, in which case all classes matching the patternset     will be searched and their corresponding methods will be kept.      No"},{"location":"task_documentation.html#child-elements_9","title":"Child Elements","text":"<ul> <li>patternset</li> </ul>"},{"location":"task_documentation.html#examples_1","title":"Examples","text":"<pre><code>&lt;method class=\"com.mycompany.myapp.MyClass\"\n  name=\"void main(java.lang.String[])\"/&gt;\n&lt;method class=\"com.mycompany.myapp.MyClass\"\n  name=\"int foo(double[][], java.lang.Object)\"/&gt;\n&lt;method name=\"void writeObject(java.io.ObjectOutputStream)\"&gt;\n  &lt;patternset&gt;\n    &lt;include name=\"com.mycompany.myapp.data.*\"/&gt;\n  &lt;/patternset&gt;\n&lt;/method&gt;\n&lt;method name=\"void readObject(java.io.ObjectInputStream)\"&gt;\n  &lt;patternset&gt;\n    &lt;include name=\"com.mycompany.myapp.data.*\"/&gt;\n  &lt;/patternset&gt;\n&lt;/method&gt;\n</code></pre> <p>This will keep the main method of the <code>MyClass</code> class and the <code>foo</code> method. Additionally all <code>readObject</code> and <code>writeObject</code> methods (used for serialization) will be kept in all classes of the <code>com.mycompany.myapp.data</code> package. Note that you have to specify the return argument's type, even if it is void and that you have to use the fully qualified name for all classes, even those, that are in the <code>java.lang package</code>.</p>"},{"location":"task_documentation.html#the-field-element","title":"The <code>field</code> Element","text":"<p>Using the <code>field</code> element you can specify fields by name which should be excluded from shrinking or name obfuscation.</p>"},{"location":"task_documentation.html#attributes_10","title":"Attributes","text":"Attribute Description Required <code>name</code>      Specifies the field to keep.     Use the name of the field only, do not include its type!      Yes <code>class</code>      Specifies the class which contains the field.     Use the normal java syntax, i.e. the fully qualified name.     This attribute can be omitted, if the     <code>patternset</code> element is used as     a child element, in which case the all classes matching the     patternset will be searched and their corresponding fields will be     kept.      No"},{"location":"task_documentation.html#child-elements_10","title":"Child Elements","text":"<ul> <li>patternset</li> </ul>"},{"location":"task_documentation.html#examples_2","title":"Examples","text":"<pre><code>&lt;field class=\"com.mycompany.myapp.MyClass\" name=\"field\"/&gt;\n&lt;field name=\"serialVersionUID\"&gt;\n  &lt;patternset&gt;\n    &lt;include name=\"com.mycompany.myapp.data.*\"/&gt;\n  &lt;/patternset&gt;\n&lt;/field&gt;\n</code></pre> <p>This will keep the field named <code>field</code> of the <code>MyClass</code> class. Additionally all the <code>serialVersionUID</code> fields (used for serialization) will be kept in all classes of the <code>com.mycompany.myapp.data</code> package.</p>"},{"location":"task_documentation.html#the-package-element","title":"The <code>package</code> Element","text":"<p>The <code>package</code> element can be used for excluding certain package's names from the renaming process. It cannot be used for the shrinking process.</p> <p>All packages that are matched be the nested patternset element will not be obfuscated. This has no influence on the class, method, or field names but will only result in the package's name not being obfuscated. Normally, it is not necessary to use this element, instead the class element is used to keep class names (and thus their package names) from being obfuscated.</p>"},{"location":"task_documentation.html#child-elements_11","title":"Child Elements","text":"<ul> <li>patternset</li> </ul>"},{"location":"task_documentation.html#example_2","title":"Example","text":"<pre><code>&lt;package&gt;\n  &lt;patternset&gt;\n    &lt;include name=\"com.mycompany.myapp.*\"/&gt;\n  &lt;/patternset&gt;\n&lt;/package&gt;\n</code></pre> <p>This will keep the names of all packages that are direct descendants of <code>com.mycompany.myapp</code>. This will not influence the names of the classes contained in these packages.</p>"},{"location":"task_documentation.html#the-sourcefile-element","title":"The <code>sourcefile</code> Element","text":"<p>The <code>sourcefile</code> element allows for a special treatment of the sourceFile attribute by the rename element. Using nested property elements, the mapping of sourceFile attributes in obfuscated class files can be adjusted.</p>"},{"location":"task_documentation.html#attributes_11","title":"Attributes","text":"Name Description <code>mapping</code>      The value of this property determines the name all     <code>sourceFile</code> attributes matched by the     <code>sourcefile</code> element are mapped to."},{"location":"task_documentation.html#child-elements_12","title":"Child Elements","text":"<ul> <li>property</li> <li>patternset</li> </ul>"},{"location":"task_documentation.html#example_3","title":"Example","text":"<pre><code>&lt;sourcefile&gt;\n  &lt;property name=\"mapping\" value=\"y\"/&gt;\n  &lt;patternset&gt;\n    &lt;include name=\"com.mycompany.myapp.**\"/&gt;\n  &lt;/patternset&gt;\n&lt;/sourcefile&gt;\n</code></pre> <p>This will map all of the <code>sourceFile</code> attributes in the packages below <code>com.mycompany.myapp</code> to \"y\", which is small and generally a nice letter.</p>"},{"location":"task_documentation.html#the-linenumbertable-element","title":"The <code>linenumbertable</code> Element","text":"<p>The <code>linenumbertable</code> element allows for a special treatment of the linenumbertable attribute by the rename element.</p> <p>Using nested <code>property</code> elements, the mapping of <code>linenumbertable</code> attributes in obfuscated class files can be adjusted.</p>"},{"location":"task_documentation.html#attributes_12","title":"Attributes","text":"Name Description <code>mapping-scheme</code>      Can be used with the following two values:     <ul> <li> <code>scramble</code>         This will use a non-trivial algorithm to scramble the line         numbers in the existing file.         The algorithm implemented uses a different scrambling scheme for         each class. The optional         <code>scrambling-salt</code> property can be         used to provide an integer value that will be used to \"salt\"         the algorithm's random seed for the scrambling.         The size of the (uncompressed) .class file will not change using         this mapping scheme.         </li> <li> <code>squeeze</code>         This will use a simple algorithm that virtually puts all of a         method's code into the first line of code of the method. It will         appear as if each method had been written in a single line of         code.         The advantage of this scheme is drastically reduced size         requirements and thus smaller .class files, while at the same         time it will be possible to unambiguously determine the exact         method from a stacktrace.         </li> </ul> <code>scrambling-salt</code>      Can be used in conjunction with     <code>mapping-scheme</code> to provide an integer     value that will be used to \"salt\" the algorithm's random seed for     the scrambling."},{"location":"task_documentation.html#child-elements_13","title":"Child Elements","text":"<ul> <li>property</li> <li>patternset</li> </ul>"},{"location":"task_documentation.html#examples_3","title":"Examples","text":"<pre><code>&lt;linenumbertable&gt;\n  &lt;patternset&gt;\n    &lt;include name=\"com.mycompany.myapp.**\"/&gt;\n  &lt;/patternset&gt;\n&lt;/linenumbertable&gt;\n</code></pre> <p>This will keep the line numbers of all the classes in the <code>com.mycompany.myapp</code> packages and subpackages. Note that in order to see the line numbers in stacktraces, the sourcefile attribute has to be retained for those files, too, since otherwise the JDK will display \"Unknown source\" for the stack elements.</p> <pre><code>&lt;linenumbertable&gt;\n  &lt;property name=\"mapping-scheme\" value=\"scramble\"/&gt;\n  &lt;property name=\"scrambling-salt\" value=\"1234\"/&gt;\n  &lt;patternset id=\"CompanyPatternSet\"&gt;\n    &lt;include name=\"com.mycompany.myapp.**\"/&gt;\n  &lt;/patternset&gt;\n&lt;/linenumbertable&gt;\n&lt;sourcefile&gt;\n  &lt;property name=\"mapping\" value=\"y\"/&gt;\n  &lt;patternset refid=\"CompanyPatternSet\"/&gt;\n&lt;/sourcefile&gt;\n</code></pre> <p>This will keep scrambled line numbers for all classes found in and below the <code>com.mycompany.myapp</code> packages. The scrambling algorithm will use the given \"salt\" value to use a predefined scrambling scheme. In order to see the scrambled line numbers, a sourcefile element is used on the same patternset, which is referenced by its previously declared reference id, to rename the source files to \"y\".</p>"},{"location":"task_documentation.html#the-adjust-element","title":"The <code>adjust</code> Element","text":"<p>Using the <code>adjust</code> element one can specify resource files whose names and/or contents should be adjusted by the rename engine to reflect the obfuscated class names.</p> <p>Note: This will only adjust files that are part of the inoutpair jars! I.e. the fileset's root directory is the combined root of all jars that are passed to yGuard via the <code>inoutpair</code> elements. yGuard will not modify any of the files on disk, except for the out-jar!</p>"},{"location":"task_documentation.html#attributes_13","title":"Attributes","text":"Attribute Description Required <code>replaceContentPolicy</code>      Specifies if and how the content of resource files should be adjusted.     See replaceContentPolicy     for supported values.      No, defaults to <code>none</code> <code>replaceContent</code> Deprecated - use <code>replaceContentPolicy</code> instead.     Specifies whether or not the contents of resource files should be     adjusted.      No, defaults to <code>false</code> <code>replaceContentSeparator</code>      Specifies which separator is used to replace text in content.     Supports <code>.</code>, <code>/</code>, and <code>./</code>.      No, defaults to <code>/</code> <code>replacePathPolicy</code>      Specifies if and how the file names of resource files should be adjusted.     See replacePathPolicy     for supported values.      No, defaults to <code>path</code> <code>replacePath</code> Deprecated - use <code>replacePathPolicy</code> instead.     Specifies whether or not the paths to the resource files should be     adjusted.      No, defaults to <code>true</code> <code>replaceName</code> Deprecated - use <code>replacePathPolicy</code> instead.     Specifies whether or not the names of the specified resources should     be adjusted.      No, defaults to <code>false</code>"},{"location":"task_documentation.html#the-replacecontentpolicy-attribute","title":"The replaceContentPolicy Attribute","text":"<p> Specifies if and how the content of resource files should be adjusted. Supported values are: </p> <code>none</code> <p>   The content of resource files is not adjusted.   </p> <code>lenient</code> <p>   Text that is recognized as qualifed class or package name is replaced.      This policy matches the yGuard 3.x behavior for    <code>replaceContent=\"true\"</code> </p> <code>strict</code> <p>   Text that is recognized as qualifed class name is replaced.      This policy matches the yGuard 2.x behavior for    <code>replaceContent=\"true\"</code> </p>"},{"location":"task_documentation.html#the-replacepathpolicy-attribute","title":"The replacePathPolicy Attribute","text":"<p> Specifies if and how the file names of resource files should be adjusted. Supported values are: </p> <code>none</code> <p>   The paths to and names of resource files are not adjusted.      The names of service provider configuration files are not adjusted.      This policy matches the yGuard 3.x behavior for    <code>replaceName=\"false\" replacePath=\"false\"</code> </p> <code>path</code> <p>   The paths to resource files are adjusted, if they match the package name of a   renamed package.   The names of resource files are not adjusted.      The names of service provider configuration files are not adjusted.      This policy matches the yGuard 3.x behavior for    <code>replaceName=\"false\" replacePath=\"true\"</code> </p> <code>name</code> <p>   The paths to resource files are not adjusted.   The names of resource files are adjusted, if the path to and the name of   the resource file match the qualified name of a renamed class.      The names of service provider configuration files are adjusted, if the name of   the configuration file matches the qualified name of a renamed class.      This policy matches the yGuard 3.x behavior for    <code>replaceName=\"true\" replacePath=\"false\"</code> </p> <code>file</code> <p>   The paths to and names of resource files are adjusted, if they match the   qualified name of a renamed class.      The names of service provider configuration files are adjusted, if the name of   the configuration file matches the qualified name of a renamed class.      This policy matches the yGuard 3.x behavior for    <code>replaceName=\"true\" replacePath=\"true\"</code> </p> <code>fileorpath</code> <p>   Combines policies <code>file</code> and <code>path</code>.      I.e. if the path to and name of a resource file match the qualified name   of a renamed class, both path and name are adjusted accordingly.   If the path and name do not match the qualified name of a renamed class,   but the path matches the package name of a renamed package, the path is   adjusted accordingly.   If the path does not match the package name of a renamed package, but   path fragments match the package name of a renamed package,   those path fragments are adjusted accordingly.      The names of service provider configuration files are adjusted, if the name of   the configuration file matches the qualified name of a renamed class.   </p> <code>lenient</code> <p>   Tries to adjust as much of the paths to and names of resource and service   provider configuration files as possible.      For paths to and names of resource files, this policy is the same as   <code>fileorpath</code>.       The names of service provider configuration files are adjusted, if the name of   the configuration file matches the qualified name of a renamed class.   If the name does not match the qualified name of a renamed class, but   name fragments match the package name of a renamed package,   those name fragments are adjusted accordingly.   </p>"},{"location":"task_documentation.html#explanation_1","title":"Explanation","text":"<p> Suppose yGuard's input set consists of the following files </p> <pre><code>com/mycompany/myproduct/MyClass.class\ncom/mycompany/myproduct/MyClass.properties\ncom/mycompany/myproduct/SomeResource.txt\ncom/mycompany/shared/SharedResource.txt\nMETA-INF/services/com.mycompany.myproduct.MyClass\nMETA-INF/services/com.mycompany.shared.SharedService</code></pre> <p> and <code>rename</code> changes the name of class <code>com.mycompany.myproduct.MyClass</code> to <code>A.A.A.A</code>.  In this case, the individual <code>replacePathPolicy</code> polices will result in the following path and name adjustments: </p> <code>path</code> <pre><code>A/A/A/MyClass.properties\nA/A/A/SomeResource.txt\nA/A/shared/SharedResource.txt\nMETA-INF/services/com.mycompany.myproduct.MyClass\nMETA-INF/services/com.mycompany.shared.SharedService</code></pre> <p>   The path <code>com/mycompany/shared</code> does not match   any package name, but its path fragments   <code>com/mycompany</code> match the package name   <code>com.mycompany</code> and thus are changed.      The two service provider configuration files are not adjusted.   </p> <code>name</code> <pre><code>com/mycompany/myproduct/A.properties\ncom/mycompany/myproduct/SomeResource.txt\ncom/mycompany/shared/SharedResource.txt\nMETA-INF/services/A.A.A.A\nMETA-INF/services/com.mycompany.shared.SharedService</code></pre> <p>   The path to and name of the second and third resource files do not match any   qualified class name in the code base and thus are not changed.       The name <code>com.mycompany.shared.SharedService</code>   does not match any qualified class name and thus is not changed.   </p> <code>file</code> <pre><code>A/A/A/A.properties\ncom/mycompany/myproduct/SomeResource.txt\ncom/mycompany/shared/SharedResource.txt\nMETA-INF/services/A.A.A.A\nMETA-INF/services/com.mycompany.shared.SharedService</code></pre> <p>   The path to and name of the second and third resource files do not match any   qualified class name in the code base and thus are not changed.       The name <code>com.mycompany.shared.SharedService</code>   does not match any qualified class name and thus is not changed.   </p> <code>fileorpath</code> <pre><code>A/A/A/A.properties\nA/A/A/SomeResource.txt\nA/A/shared/SharedResource.txt\nMETA-INF/services/A.A.A.A\nMETA-INF/services/com.mycompany.shared.SharedService</code></pre> <p>   The path <code>com/mycompany/shared</code> does not match   any package name, but its path fragments   <code>com/mycompany</code> match the package name   <code>com.mycompany</code> and thus are changed.      The name <code>com.mycompany.shared.SharedService</code>   does not match any qualified class name and thus is not changed.   </p> <code>lenient</code> <pre><code>A/A/A/A.properties\nA/A/A/SomeResource.txt\nA/A/shared/SharedResource.txt\nMETA-INF/services/A.A.A.A\nMETA-INF/services/A.A.shared.SharedService</code></pre> <p>   The path <code>com/mycompany/shared</code> does not match   any package name, but its path fragments   <code>com/mycompany</code> match the package name   <code>com.mycompany</code> and thus are changed.      The name <code>com.mycompany.shared.SharedService</code>   does not match any qualified class name, but its name fragments   <code>com.mycompany</code> match the package name   <code>com.mycompany</code> and thus are changed.   </p>"},{"location":"task_documentation.html#child-elements_14","title":"Child Elements","text":"<p>The <code>adjust</code> element can be used just like the standard Ant <code>ZipFileSet</code> element.</p>"},{"location":"task_documentation.html#examples_4","title":"Examples","text":"<pre><code>&lt;!-- adjust the names of all java property files in the jars --&gt;\n&lt;adjust replacePathPolicy=\"file\"&gt;\n  &lt;include name=\"**/*.properties\"/&gt;\n&lt;/adjust&gt;\n\n&lt;!-- adjust the classnames specified within a single XML file in the jar --&gt;\n&lt;adjust file=\"plugins.xml\" replaceContentPolicy=\"strict\" replaceContentSeparator=\".\"/&gt;\n\n&lt;!-- suppress the adjustment of the resource path com/mycompany/myapp/resource in the jar. --&gt;\n&lt;!-- the package com.mycompany.myapp still gets obfuscated. --&gt;\n&lt;adjust replacePathPolicy=\"none\"&gt;\n  &lt;include name=\"com/mycompany/myapp/resource/*\"/&gt;\n&lt;/adjust&gt;\n</code></pre>"},{"location":"task_documentation.html#the-map-element","title":"The <code>map</code> Element","text":"<p>The <code>map</code> element is an immediate optional child of the rename element. It can be used to specify the mapping for the renaming process directly. This is an advanced topic.</p>"},{"location":"task_documentation.html#child-elements_15","title":"Child Elements","text":"<ul> <li>package</li> <li>class</li> <li>method</li> <li>field</li> </ul> <p>All of these elements use the <code>name</code> attribute to specify the specific element. The <code>method</code> and <code>field</code> elements need the <code>class</code> attribute in order to function properly. Neither wildcards nor nested <code>patternset</code> elements are allowed. Use the <code>map</code> attribute to specify the new name (subpackage, classname, methodname and fieldname respectively).</p>"},{"location":"task_documentation.html#examples_5","title":"Examples","text":"<pre><code>&lt;map&gt;\n  &lt;package name=\"com\" map=\"etc\"/&gt;\n  &lt;package name=\"com.mycompany\" map=\"nocompany\"/&gt;\n  &lt;package name=\"com.mycompany.myapp\" map=\"asdf\"/&gt;\n  &lt;class name=\"com.mycompany.myapp.MainApp\" map=\"foo\"/&gt;\n  &lt;method class=\"com.mycompany.myapp.MainApp\"\n    name=\"void main(java.lang.String[])\" map=\"bar\"/&gt;\n  &lt;field class=\"com.mycompany.myapp.MainApp\" name=\"field\" map=\"a\"/&gt;\n&lt;/map&gt;\n</code></pre> <p>In this example the package structure <code>com.mycompany.myapp</code> will be obfuscated to <code>etc.nocompany.asdf</code>. The <code>MainApp</code> class will be called <code>foo</code> and its <code>main</code> method will be remapped to <code>bar</code> (and can therefor not be executed from commandline anymore). The field called <code>field</code> will be renamed to <code>a</code>.</p>"},{"location":"task_documentation.html#controlling-obfuscation-exclusion-with-annotations","title":"Controlling obfuscation exclusion with annotations","text":"<p>In order to exclude certain elements from obfuscation, it is possible to use annotations in the source code instead of listing those elements in the keep element.</p> <p>Any annotation class can be used for this, but it must be specified in the <code>annotationClass</code> attribute of the rename element and follow the convention as explained below to work. yGuard contains such an annotation in the distribution package ready for use. The annotation class is <code>com.yworks.util.annotation.Obfuscation</code> and can be found in the yGuard distribution in <code>ObfuscationAnnotation.jar</code>. Feel free add this attribute definition to your own codebase and possibly adjust the package name to your needs. Here is the source code for it:</p>"},{"location":"task_documentation.html#obfuscationjava","title":"<code>Obfuscation.java</code>","text":"<pre><code>package com.yworks.util.annotation;\n\npublic @interface Obfuscation {\n\n  boolean exclude() default true;\n\n  boolean applyToMembers() default true;\n}\n</code></pre> <p>This class is also the default annotation yGuard is looking for when obfuscating. By default the <code>Obfuscation</code> annotation is inherited using the <code>@Inherited</code> trait. If this behaviour is undesirable, consider creating a custom obfuscation annotation.</p> <p>The convention for annotation classes that yGuard understands as obfuscation controlling annotations requires two attributes:</p> Attribute Description Default value <code>exclude</code>      Specifies whether the annotated element should be excluded from the     obfuscation. Note, that when retaining a class, the hierarchy of     that class, i.e. the chain of outer class names and the package     name, is also retained.      <code>true</code> <code>applyToMembers</code>      Specifies whether the child elements of the annotated element, if     not otherwise specified, should be excluded from the obfuscation.     For example, when annotating a class with     <code>exclude = true</code> and this attribute set to     <code>true</code>, inner classes, fields and methods of this     class will be excluded from obfuscation. Annotating a child element     of an element that has this attribute set to <code>true</code> will     override the parents annotation configuration.      <code>true</code>"},{"location":"task_documentation.html#generating-patch-jars","title":"Generating Patch JARs","text":"<p>The true power of the <code>map</code> element lies in its use together with the <code>patch</code> element, which itself is a child element of the <code>rename</code> top level element.</p>"},{"location":"task_documentation.html#attributes_14","title":"Attributes","text":"<p>The <code>patch</code> element has no attributes.</p>"},{"location":"task_documentation.html#child-elements_16","title":"Child Elements","text":"<ul> <li>class</li> </ul>"},{"location":"task_documentation.html#examples_6","title":"Examples","text":"<p>Using the <code>patch</code> element one can generate jars, that can be used to serve as patches for versions of an application that have already been deployed in obfuscated form. During the main obfuscation run, yGuard produces an xml-logfile, in which the mapping between the unobfuscated and obfuscated names is contained. The patch element is used to declare a set of classes, that need to be patched. During the obfuscation, yGuard will include those files in the obfuscated jars only, that are declared inside this element.</p> <pre><code>&lt;patch&gt;\n  &lt;class name=\"com.mycompany.myapp.MainClass\"/&gt;\n  &lt;class&gt;\n    &lt;patternset&gt;\n      &lt;include name=\"com.mycompany.myapp.bugs.*\"/&gt;\n    &lt;/patternset&gt;\n  &lt;/class&gt;\n&lt;/patch&gt;\n&lt;map logfile=\"yguardlog.xml\"/&gt;\n</code></pre> <p>This will only include the MainClass class and all classes that belong to the bugs package in a patch jar. In order to work with the previously delivered obfuscated version, it is important to use the map element to specify the mapping of the elements from the previous run. This can most conveniently be achieved by specifying the log file from the corresponding run in the map element's logfile attribute.</p>"},{"location":"task_documentation.html#deobfuscating-stacktraces","title":"Deobfuscating stacktraces","text":"<p>yGuard provides a simple tool that makes it easy for the obfuscating party to deobfuscate stacktraces which have been obfuscated using yGuard. During the obfuscation yGuard produces an xml logfile which can automatically be gzipped for convenient storage. You should always keep those logfiles in order to be able to deobfuscate fully qualified classnames or methods or fields for debugging purposes e.g. In order to run the yGuard deobfuscation tool do the following:</p> <pre><code>Console&gt; java -jar yguard.jar mylogfile.xml\n</code></pre> <p>A tiny GUI will popup that will enable you to easily deobfuscate stacktraces and fully qualified classnames as well as provide a convenient way to browse the mapping generated by yGuard. In the main window a tree view displays the package, class, and classmember hierarchy using the unobfuscated names. For each entry that has been obfuscated (classes, packages, methods, and fields that have not been obfuscated at all may not always be shown in the tree) the corresponding mapped/obfuscated name is displayed. The two buttons at the top of the window allow to change the sorting of the items in the tree structure, so that they are either sorted according to their names before or after the obfuscation. Items will always be sorted by type first: packages, classes, innerclasses, methods, and fields. Small icons provide a convenient way to quickly find the corresponding items.</p> <p>The lower part of the window contains an editable text area that can be used to enter text or paste stacktraces in. Pressing the button at the bottom of the window labelled \"Deobfuscate\" will trigger the deobfuscation of the contents in the text area. The tool will try to identify fully qualified class names (separated by dots) and use the mapping information to reconstruct the original names. If the tool identifies a stack trace element, it will try to deobfuscate scrambled line numbers, too, if they have been scrambled during the obfuscation process.</p>"},{"location":"task_documentation.html#dtd-used-for-ant-yguard","title":"DTD used for Ant <code>&lt;yguard&gt;</code>","text":"<p>The obfuscation and shrinking process can be completely configured inside your Ant script. The yguard task and nested elements should be used according to the following DTD. Note that this is for information purposes only, i.e. you do not have to include the following lines anywhere. This DTD should just provide a quick overview of the yGuard syntax. Due to restrictions of the DTD specification, the given DTD does not describe all available yGuard options. Please browse through the documentation above for complete documentation of the yGuard Ant task elements.</p> <pre><code>&lt;!ELEMENT yguard (inoutpair+,externalclasses?,attribute*,(shrink|rename)+)&gt;\n\n&lt;!ELEMENT inoutpair EMPTY&gt;\n&lt;!ATTLIST inoutpair\nin CDATA #REQUIRED\nout CDATA #REQUIRED\nresources CDATA #IMPLIED&gt;\n&lt;!--\nNOTE: the resources attribute only has an effect if a shrink element is present inside the yguard element.\n--&gt;\n\n&lt;!ELEMENT externalclasses ANY&gt;\n&lt;!-- the externalclasses element is used just like Ant's classpath\nelement. See the Ant documentation for further details--&gt;\n\n&lt;!ELEMENT attribute (patternset)*&gt;\nname CDATA #REQUIRED&gt;\n\n&lt;!ELEMENT shrink (entrypointjar*,keep?)&gt;\n&lt;!ATTLIST shrink\nlogfile CDATA #IMPLIED\ncreateStubs CDATA #IMPLIED&gt;\n\n&lt;!ELEMENT entrypointjar&gt;\n&lt;!ATTLIST entrypointjar\nname CDATA #REQUIRED&gt;\n\n&lt;!ELEMENT rename (property*,patch?,adjust*,map?,keep?)&gt;\n&lt;!ATTLIST rename\nmainclass CDATA #IMPLIED\nlogfile CDATA #IMPLIED\nconservemanifest CDATA #IMPLIED\nreplaceClassNameStrings CDATA #IMPLIED&gt;\n\n&lt;!ELEMENT property EMPTY&gt;\n&lt;!ATTLIST property\nname CDATA #REQUIRED\nvalue CDATA #REQUIRED&gt;\n\n&lt;!ELEMENT patch (class)*&gt;\n\n&lt;!ELEMENT adjust (#PCDATA)&gt;\n&lt;!ATTLIST adjust\nreplaceName CDATA #REQUIRED\nreplaceContent CDATA #REQUIRED\nreplacePath CDATA #REQUIRED&gt;\n\n&lt;!ELEMENT map (class|method|field|package)*&gt;\n\n&lt;!ELEMENT package (patternset)*&gt;\n&lt;!ATTLIST package\nname CDATA #REQUIRED\nmap CDATA #REQUIRED&gt;\n&lt;!--\nNOTE: the map attribute is only supported\nif the &lt;package&gt; element is nested inside a &lt;map&gt; element, whereas the patternset is\nonly supported inside the &lt;keep&gt;/&lt;expose&gt; sections.\n--&gt;\n\n&lt;!ELEMENT keep (package|class|method|field|sourcefile|linenumbertable)*&gt;\n&lt;!--\nNOTE: the nested &lt;package&gt;,&lt;sourcefile&gt;,&lt;linenumbertable&gt; and &lt;attribute&gt; sections are only\nsupported in the &lt;rename&gt; element.\n--&gt;\n&lt;!ATTLIST keep\nlinenumbertable CDATA #IMPLIED\nlocalvariabletable CDATA #IMPLIED\nlocalvariabletypetable CDATA #IMPLIED\nruntimeinvisibleannotations CDATA #IMPLIED\nruntimeinvisibletypeannotations CDATA #IMPLIED\nruntimevisibleannotations CDATA #IMPLIED\nruntimevisibletypeannotations CDATA #IMPLIED\nsourcefile CDATA #IMPLIED&gt;\n\n&lt;!ELEMENT class (patternset)*&gt;\n&lt;!ATTLIST class\nclasses CDATA #IMPLIED\nfields CDATA #IMPLIED\nmap CDATA #IMPLIED\nmethods CDATA #IMPLIED\nname CDATA #IMPLIED&gt;\n&lt;!--\nNOTE: the map attribute is only supported\nif the &lt;class&gt; element is nested inside an &lt;rename&gt; element.\n--&gt;\n\n&lt;!ELEMENT method (patternset)*&gt;\n&lt;!ATTLIST method\nclass CDATA #IMPLIED\nmap CDATA #IMPLIED\nname CDATA #IMPLIED&gt;\n&lt;!--\nNOTE: the map attribute is only supported\nif the &lt;method&gt; element is nested inside an &lt;rename&gt; element.\n--&gt;\n\n&lt;!ELEMENT field (patternset)*&gt;\n&lt;!ATTLIST field\nclass CDATA #IMPLIED\nmap CDATA #IMPLIED\nname CDATA #IMPLIED&gt;\n&lt;!--\nNOTE: the field attribute is only supported\nif the &lt;method&gt; element is nested inside an &lt;rename&gt; element.\n--&gt;\n</code></pre> <p>Attention users of IDEs that \"support\" the creation of Ant files (e.g. IDEA's IntelliJ): Your IDE may indicate some errors inside your ANT file when you use yGuard specific elements. This is because the IDE does not know about the DTD used by yGuard. However this is not a real problem, since the Ant file should nevertheless work as expected.</p>"},{"location":"troubleshooting.html","title":"Troubleshooting","text":"<p>There are a couple of things you should be aware of when obfuscating and shrinking software. The weakest part of an application considering name obfuscation and code shrinking is code that uses reflection to dynamically load classes, invoke methods etc. Therefore, you have to be especially careful when using the yguard task on applications that rely on reflection. The most important facts to keep in mind when using yGuard are described here briefly:</p> <ul> <li>If you use the <code>rename</code> task, code in the form of <code>MyApplication.class</code> will break if <code>MyApplication</code> will be obfuscated by name and the obfuscation switch replaceClassNameStrings is set to <code>false</code>. The <code>shrink</code> task will currently recognize code in the form of <code>MyApplication.class</code> only if the java files were compiled using an arbitrary version of the standard javac compiler (although the shrinking engine might recognize the <code>.class</code> construct also if the classes were compiled using a compiler that generates similar bytecode).</li> <li>Automatic introspection and reflection will break in most cases, when you decide to obfuscate the corresponding methods and fields. If you use the <code>shrink</code> task and your application uses reflection you should explicitly designate all entities loaded per reflection as code entrypoints using the keep element. If your application is broken after using the <code>shrink</code> task, consider using the createStubs attribute of the <code>shrink</code> task to find out which additional entities you need to include in the keep element.</li> <li><code>Class.forName(className)</code> will not work when using the <code>rename</code> task unless you use the obfuscated name string in your variable or the String is a local constant and replaceClassNameStrings is not set or set to <code>true</code>. If you use the <code>shrink</code> task, <code>className</code> should be contained in the list of entrypoints using the <code>keep</code> element.</li> <li>The customized serialization mechanism will not work if you obfuscated or shrinked the writeObject and readObject methods as well as the serializationUID field.</li> <li>Simple bean introspection will not work, if you decide to obfuscate your public accessor methods, since it makes use of reflection.</li> <li>If you do not set the <code>-Xmx</code> property for the Java virtual machine, the <code>yguard</code> Ant task might fail due to a <code>java.lang.OutOfMemoryError</code>. To solve this problem, set the <code>-Xmx</code> option in the <code>ANT_OPTS</code> variable, e.g.:</li> </ul> <pre><code>bash&gt; export ANT_OPTS=\"-Xmx512M\"\nor\ncshell&gt; setenv ANT_OPTS \"-Xmx512M\"\n</code></pre>"}]}