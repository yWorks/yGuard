<html>

<head>
  <title>YShrink Internal Documentation</title>
</head>

<style type="text/css">

  /*pre {*/
  /*display: inline;*/
  /*color: #000033;*/
  /*}*/


</style>

<body>

<p><h1>YShrink Internal Documentation</h1></p>

<h2>Contents</h2>
<ul>
  <li><a href="#overview">Overview</a></li>
  <li><a href="#dependency">Dependency Analysis</a></li>
  <ul>
    <li><a href="#model-edges">Basic Model Edges</a></li>
    <li><a href="#invocations">Method Invocations</a></li>
    <li><a href="#assume">External Dependenciesn, Entrypoints</a></li>
    <li><a href="#typeinstructions">Type Instructions</a></li>
    <li><a href="#signatures">Method Signatures</a></li>
    <li><a href="#references">Field References</a></li>
    <li><a href="#.class">.class-Construct</a></li>
  </ul>
  <li><a href="#shrinking">Shrinking</a></li>
</ul>

<p>
  <a name="overview">
    <h2>Overview</h2>
  </a>
  <h4>basic steps in <code>com.yworks.yshrink.YShrink.doShrinkPairs()</code>:</h4>
  <ol>
    <li>Init model: create nodes for each class, method and field. Additionally, create a single entrypoint-node and one
      NEW-node for each class.</li>
    <li>Mark all entrypoints: using a composite EntryPointFilter, mark/log every entrypoint-node in the model.</li>
    <li>Create all dependency edges using the <code>com.yworks.yshrink.core.Analyzer</code>.</li>
    <li>Create additional entrypoint-edges between the entrypoint-node and each entrypoint that <i>doesn't represent an
      ordinary method (non-abstract,non-static,non-constructor).</i></li>
    <li>Mark all obsolete classes, methods and fields using the <code>com.yworks.yshrink.core.Shrinker</code>.</li>
    <li>Write out all non-obsolete classes using the <code>com.yworks.yshrink.core.Writer</code>.</li>
  </ol>
</p>

<p>
<a name="dependency">
  <h2>Dependency Analysis</h2>
</a>

<div class="section">
  <div class="head">
    <a name="model-edges"><h4><u>Basic Model Edges</u></h4></a>
  </div>

  <div class="content">
    <ul>
      <li>
        Create EXTENDS edges from each class to its superclass, if the superclass is contained in the model.<br>
        [Method: com.yworks.yshrink.core.Analyzer.createInheritanceEdges()]
      </li>
      <li>
        Create IMPLEMENTS edges from each class to all of its interfaces, if the interface is contained in the model.
        <br>
        [Method: com.yworks.yshrink.core.Analyzer.createInheritanceEdges()]
      </li>
      <li>
        Create MEMBER_OF edges from each method, field and from the special NEW-node to the class it belongs to.
      </li>
      <li>
        Create ENCLOSE edge from each inner class to its enclosing class or method.
      </li>

    </ul>
  </div>
</div>

<div class="section">
  <div class="head">
    <a name="invocations"><h4><u>Method Invocations</u></h4></a>
  </div>

  <div class="content">
    Basic Algorithm:.<br/>

    <ul>
      <li>
        Create INVOKE and RESOLVE edges to the first implementation of the target method found in the target class or
        any superclass of the target class.<br/>
        While searching for the implementation, create RESOLVE edges to each class that does not implement the target
        method.<br/>
        [Method: <code>com.yworks.yshrink.core.Analyzer.createEdgesToAncestorMethods()</code>]
      </li>
      <li>
        Create INVOKE edges to all implementations of the target method in any sublcasses of the target class.<br/>
        [Method: <code>com.yworks.yshrink.core.Analyzer.createSubtreeEdges()</code>]
      </li>
    </ul>

    Special Rules:

    <ul>
      <li>
        If the target class is an interface, the basic algorithm is run on all implementations of that interface.<br/>
        [Method: <code>com.yworks.yshrink.core.Analyzer.createEdgesToAncestorMethods()</code>]</li>
      <li>
        If the target class is an interface or the target class is abstract and the target method is declared in any
        parent
        interface of the abstract class, a RESOLVE edge is created to the declaration of the target method.<br/>
        [Method: <code>com.yworks.yshrink.core.Analyzer.createEdgeToDeclation()</code>]
      </li>
      <li>
        If the invocation is a call to a super method, the basic algorithm is NOT applied. Instead: <br>
        <ul>
          <li>If the call is a "chain" call to the super-constructor, a special CHAIN edge is created.</li>
          <li>
            Else, a SUPER edge is created to the implementation of the target method in the first super
            class of the target class that implements the target method.
          </li>
        </ul>
        [Method: <code>com.yworks.yshrink.core.Analyzer.createInvokeEdges()</code>]
      </li>
      <li>
        For constuctor calls, an ordinary INVOKE edge is created to the specific &lt;init&gt; method.<br/>
        Additionally, a special CREATES Edge is created to the special NEW node in [Method: <code>
        com.yworks.yshrink.core.Analyzer.createTypeInstructionEdges()</code>],
        indicating that the target class is instantiated.
      </li>
    </ul>

  </div>
</div>


<div class="section">
  <div class="head">
    <a name="assume"><h4><u>External Dependencies, Entrypoints</u></h4></a>
  </div>

  <div class="content">
    <ul>
      <li>If a class inherits from any external class that cannot be resolved, ASSUME edges are created from the
        NEW-node to every none-private method.</li>
      <li>If all external classes/interfaces that a class inherits from can be resolved, ASSUME edges are created from
        the NEW-node to any
        method overriding a method of the external ancestor classes/interfaces. <br/>
        If the class itself does not override an externally defined method, the parent classes of that class contained
        in the model are searched for an
        implementation and the ASSUME edge is created to that implementation instead.</li>
      <li>For all entrypoint-methods that are members of an ancestor class that is contained in the model,
        an ASSUME edge is created from the NEW-node to its implementation in the class itself or a parent class.</li>
    </ul>
    [Method: <code>com.yworks.yshrink.core.Analyzer.createAssumeEdges()</code>]
  </div>
</div>

<div class="section">
  <div class="head">
    <a name="typeinstructions"><h4><u>Type Instructions</u></h4></a>
  </div>

  <div class="content">
    <ul>
      <li>
        For each type instruction with opcode ANEWARRAY, MULTIANEWARRAY, INSTANCEOF, CHECKCAST or LDC (class version >=
        0.49),
        a RESOLVE edge is created from the source method to the corresponding type.
      </li>
      <li>
        If the opcode is NEW, a CREATES edge is created to the NEW-node of the corresponding type.
      </li>
    </ul>
  </div>
  [Method: <code>com.yworks.yshrink.core.Analyzer.createTypeInstructionEdges()</code>]
</div>

<div class="section">
  <div class="head">
    <a name="signatures"><h4><u>Method Signatures</u></h4></a>
  </div>

  <div class="content">
    <ul>
      <li>RESOLVE edges are created from each method to its return type, exception types and argument types.</li>
    </ul>
    [Method: <code>com.yworks.yshrink.core.Analyzer.createMethodSignatureEdges()</code>]
  </div>
</div>


<div class="section">
  <div class="head">
    <a name="references"><h4><u>Field References</u></h4></a>
  </div>

  <div class="content">
    <ul>
      <li>
        A REFERENCES edge is created from the referencing method to the field in the class the declares the field.
        If the field is not declared in the runtime class, the superclasses and interfaces of the
        runtime class are searched for the declaration. While searching for the declaration,
        RESOLVE edges are created to the visited concrete classes.
      </li>
    </ul>
    [Method: <code>com.yworks.yshrink.core.Analyzer.createReferenceEdges()</code>]
  </div>
</div>

<div class="section">
  <div class="head">
    <a name=".class"><h4><u>.class-construct</u></h4></a>
  </div>

  <div>
    <ul>
      <li>
        If the version of a class is &gt;= 0.49, the <code>.class</code>-construct is easily identified by LDC opcodes.
        <br>
        [Method: <code>com.yworks.yshrink.core.Analyzer.createTypeInstructionEdges()</code>]
      </li>
      <li>
        If the version of a class is &lt; 0.49, the <code>.class</code>-construct is identified by checking each field
        in [Method: <code>com.yworks.yshrink.core.Analyzer.createReferenceEdges()</code>]
        for the synthetic field "<code>class$..</code>" that is inserted in the bytecode by javac. RESOLVE edges are
        created to all possible classes given by the name of the synthetic field. <br/>
        [Method: <code>com.yworks.yshrink.core.Analyzer.checkLegacyDotClassField()</code>]
      </li>
      <li><b>jikes/eclipse compiler etc are not yet accounted for.</b></li>
    </ul>
  </div>
</div>

<!--
  <div class="section">
    <div class="head">
    	<a name="assume"><h4><u>External Dependencies, Entrypoints</u></h4></a>
	  </div>
    <div class="content">
      <ul>
        <li></li>
      </ul>
    </div>
  </div>
-->

</p>


<p>
  <a name="shrinking">
    <h2>Shrinking</h2>
  </a>

  <div class="section">
    <ul>
      <li>Initially, no node is marked as instantiated and all nodes are marked as obsolete.</li>
      <li>Using the global entrypoint-node as the startnode, a dfs is run on the dependency graph.</li>
      <li>Edges are traversed under the following conditions: </li>
      <ul>
        <li>If the target node is a class or field node, the edge may always be traversed.</li>
        <li>An edge to a method node may be traversed if it is not a RESOLVE edge and: </li>
        <ul>
          <li>The target method is static or</li>
          <li>The edge represents a super call or </li>
          <li>The target node is the NEW-node of a class or</li>
          <li>The target method is a constructor or</li>
          <li>The target method is private or</li>
          <li>The target method is a regular method and the class the method belongs to is marked as instantiated
            or</li>
          <li>The target method is needed, i.e. a child class of the class the method belongs to is instantiated and
            does not override the method.</li>
        </ul>
      </ul>
      <li>If an edge is allowed to be traversed and the target node is a NEW-node, the corresponding class is marked as
        instantiated.</li>
      <li>As long as the amount of classes marked as instantiated increases, rerun the dfs.</li>
      <li>If the amount of classes marked as instantiated does not increase between two dfs-rounds,
        a last dfs is run in order to mark all reachable nodes as non-obsolete.
        Also, the RESOLVE edges that target methods are allowed to be traversed in this last round in
        order to mark the target methods as needed for resolving (that is, only a stub of these methods is
        needed). </li>
    </ul>
  </div>
</p>


<p>

</p>
</body>
</html>